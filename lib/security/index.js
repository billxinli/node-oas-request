const signJWT = require('./jwt')

module.exports = async function (oasSecuritySchemes, securityRequirements, securityOptions) {
  const headers = {}
  const queries = {}

  // We only need to set these values if there are security schemes defined within the OAS
  if (oasSecuritySchemes) {
    // For each required security mechanism
    for await (const key of Object.keys(securityRequirements)) {
      const securityScheme = oasSecuritySchemes[key]
      const securityOption = securityOptions[key]

      // Ensure the required security mechanism is defined in the OAS, AND given as a configuration
      if (!securityScheme || !securityOption) {
        throw new Error(`Security scheme ${key} not defined in spec.`)
      }

      /**
       * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
       *
       * REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "oauth2", "openIdConnect".
       *
       * Only apiKey and http options are implemented here
       */
      switch (securityScheme.type) {
        case 'oauth2':
        case 'openIdConnect':
          throw new Error(`${securityScheme.type} type not implemented.`)

        // http type
        case 'http':
          if (!headers.authorization) {
            headers.authorization = []
          }
          /**
           * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
           *
           * REQUIRED. The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.
           * The values used SHOULD be registered in the IANA Authentication Scheme registry.
           *
           * https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
           *
           * Only basic and bearer is implemented here
           */
          switch (securityScheme.scheme) {
            case 'bearer':
              /**
               * A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually
               * generated by an authorization server, so this information is primarily for documentation purposes.
               *
               * Only the JWT mechanism is used here, otherwise, the token is just a plain value
               */
              switch (securityScheme.bearerFormat) {
                case 'JWT': {
                  const { secret, exp, payload } = securityOption
                  const jwtOptions = {}
                  if (exp) {
                    jwtOptions.expiresIn = exp
                  }

                  headers.authorization.push(`Bearer ${await signJWT(payload, secret, jwtOptions)}`)
                  break
                }
                default:
                  headers.authorization.push(`Bearer ${securityOption}`)
              }
              break
            default:
              throw new Error(`${securityScheme.scheme} scheme type not implemented.`)
          }
          break // break http

        // apiKey type
        case 'apiKey':
          /**
           * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#security-scheme-object
           *
           * REQUIRED. The location of the API key. Valid values are "query", "header" or "cookie".
           *
           * Only query and header
           */
          switch (securityScheme.in) {
            case 'header':
              if (!headers[securityScheme.name]) {
                headers[securityScheme.name] = []
              }
              headers[securityScheme.name].push(securityOption)
              break
            case 'query':
              if (!queries[securityScheme.name]) {
                queries[securityScheme.name] = []
              }
              queries[securityScheme.name].push(securityOption)
              break
            case 'cookie':
              throw new Error('cookie in type not implemented.')
          }
          break // break apiKey
      }
    }
  }

  return {
    headers,
    queries
  }
}
